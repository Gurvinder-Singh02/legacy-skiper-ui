{
  "name": "image-ripple",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "three",
    "@types/three",
    "@react-three/fiber",
    "@react-three/drei"
  ],
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\"\n\nimport React, { useEffect, useRef, useState } from \"react\"\nimport { OrthographicCamera, useFBO, useTexture } from \"@react-three/drei\"\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\"\nimport * as THREE from \"three\"\n\nexport default function Scene() {\n  const device = useDimension()\n\n  if (!device.width || !device.height) {\n    return null\n  }\n\n  const frustumSize = device.height\n  const aspect = device.width / device.height\n\n  return (\n    <div className=\"relative flex h-screen w-full items-center justify-center \">\n      <Canvas>\n        <OrthographicCamera\n          makeDefault\n          args={[\n            (frustumSize * aspect) / -2,\n            (frustumSize * aspect) / 2,\n            frustumSize / 2,\n            frustumSize / -2,\n            -1000,\n            1000,\n          ]}\n          position={[0, 0, 2]}\n        />\n        <Model />\n      </Canvas>\n    </div>\n  )\n}\n\nfunction Model() {\n  const { viewport } = useThree()\n  const texture = useTexture(\"/brush.png\")\n  const meshRefs = useRef<(THREE.Mesh | null)[]>([])\n  const [meshes, setMeshes] = useState<JSX.Element[]>([])\n  const mouse = useMouse()\n  const device = useDimension()\n  const [prevMouse, setPrevMouse] = useState({ x: 0, y: 0 })\n  const [currentWave, setCurrentWave] = useState(0)\n  const { gl, camera } = useThree()\n\n  const scene = new THREE.Scene()\n  const max = 100\n\n  const uniforms = useRef({\n    uDisplacement: { value: new THREE.Texture() },\n    uTexture: { value: new THREE.Texture() },\n    winResolution: {\n      value: new THREE.Vector2(0, 0),\n    },\n  })\n\n  const fboBase = useFBO(device.width, device.height)\n  const fboTexture = useFBO(device.width, device.height)\n\n  const { scene: imageScene, camera: imageCamera } = Images(\n    new THREE.Vector2(viewport.width, viewport.height)\n  )\n\n  useEffect(() => {\n    const generatedMeshes = Array.from({ length: max }).map((_, i) => (\n      <mesh\n        key={i}\n        position={[0, 0, 0]}\n        ref={(el) => {\n          meshRefs.current[i] = el\n        }}\n        rotation={[0, 0, Math.random()]}\n        visible={false}\n      >\n        <planeGeometry args={[60, 60, 1, 1]} />\n        <meshBasicMaterial transparent={true} map={texture} />\n      </mesh>\n    ))\n    setMeshes(generatedMeshes)\n  }, [texture])\n\n  function setNewWave(x: number, y: number, currentWave: number) {\n    const mesh = meshRefs.current[currentWave]\n    if (mesh) {\n      mesh.position.x = x\n      mesh.position.y = y\n      mesh.visible = true\n      ;(mesh.material as THREE.Material).opacity = 1\n      mesh.scale.x = 1.75\n      mesh.scale.y = 1.75\n    }\n  }\n\n  function trackMousePos(x: number, y: number) {\n    if (Math.abs(x - prevMouse.x) > 0.1 || Math.abs(y - prevMouse.y) > 0.1) {\n      setCurrentWave((currentWave + 1) % max)\n      setNewWave(x, y, currentWave)\n    }\n    setPrevMouse({ x: x, y: y })\n  }\n\n  useFrame(({ gl, scene: finalScene }) => {\n    const x = mouse.x - device.width / 1.65\n    const y = -mouse.y + device.height / 1.5\n    trackMousePos(x, y)\n    meshRefs.current.forEach((mesh) => {\n      if (mesh && mesh.visible) {\n        mesh.rotation.z += 0.025\n        ;(mesh.material as THREE.MeshBasicMaterial).opacity *= 0.95\n        mesh.scale.x = 0.98 * mesh.scale.x + 0.155\n        mesh.scale.y = 0.98 * mesh.scale.y + 0.155\n      }\n    })\n\n    if (device.width > 0 && device.height > 0) {\n      // uniforms.current.uTexture.value = imageTexture;\n\n      // Render to base texture with meshes\n      gl.setRenderTarget(fboBase)\n      gl.clear()\n      meshRefs.current.forEach((mesh) => {\n        if (mesh && mesh.visible) {\n          scene.add(mesh)\n        }\n      })\n      gl.render(scene, camera)\n      meshRefs.current.forEach((mesh) => {\n        if (mesh && mesh.visible) {\n          scene.remove(mesh)\n        }\n      })\n      uniforms.current.uTexture.value = fboTexture.texture\n\n      gl.setRenderTarget(fboTexture)\n      gl.render(imageScene, imageCamera)\n      uniforms.current.uDisplacement.value = fboBase.texture\n\n      gl.setRenderTarget(null)\n      gl.render(finalScene, camera)\n\n      // Render the scene with updated displacement\n      // gl.setRenderTarget(fboTexture);\n      // gl.clear();\n      // gl.render(scene, camera);\n      // uniforms.current.uTexture.value = fboTexture.texture;\n      // gl.setRenderTarget(null);\n\n      uniforms.current.winResolution.value = new THREE.Vector2(\n        device.width,\n        device.height\n      ).multiplyScalar(device.pixelRatio)\n    }\n  }, 1)\n\n  function Images(viewport: THREE.Vector2) {\n    const scene = new THREE.Scene()\n    const camera = new THREE.OrthographicCamera(\n      viewport.width / -2,\n      viewport.width / 2,\n      viewport.height / 2,\n      viewport.height / -2,\n      -1000,\n      1000\n    )\n    camera.position.z = 2\n    scene.add(camera)\n    const geometry = new THREE.PlaneGeometry(1, 1)\n    const group = new THREE.Group()\n\n    const texture1 = useTexture(\"/picture9.jpeg\")\n    const material1 = new THREE.MeshBasicMaterial({ map: texture1 })\n    const image1 = new THREE.Mesh(geometry, material1)\n    image1.position.x = -0.3 * viewport.width\n    image1.position.y = 0\n    image1.position.z = 1\n    image1.scale.x = 1080 / 4\n    image1.scale.y = 1920 / 4\n    group.add(image1)\n\n    const texture2 = useTexture(\"/picture1.jpeg\")\n    const material2 = new THREE.MeshBasicMaterial({ map: texture2 })\n    const image2 = new THREE.Mesh(geometry, material2)\n    image2.position.x = -0.001 * viewport.width\n    image2.position.y = 0\n    image2.position.z = 1\n    image2.scale.x = 1080 / 4\n    image2.scale.y = 1920 / 4\n    group.add(image2)\n\n    // const texture3 = useTexture('/picture3.jpeg');\n    // const material3 = new THREE.MeshBasicMaterial({ map: texture3 });\n    // const image3 = new THREE.Mesh(geometry, material3);\n    // image3.position.x = 0.25 * viewport.width;\n    // image3.position.y = 0;\n    // image3.position.z = 1;\n    // image3.scale.x = viewport.width / 5;\n    // image3.scale.y = viewport.width / 4;\n    // group.add(image3);\n\n    scene.add(group)\n    return { scene, camera }\n  }\n\n  return (\n    <group>\n      {meshes}\n      {/* <Images /> */}\n      <mesh>\n        <planeGeometry args={[device.width, device.height, 1, 1]} />\n        <shaderMaterial\n          // args={[device.width, device.height, 1]}\n          vertexShader={vertex}\n          fragmentShader={fragment}\n          transparent={true}\n          uniforms={uniforms.current}\n        ></shaderMaterial>\n      </mesh>\n    </group>\n  )\n}\n\nfunction useMouse() {\n  const [mouse, setMouse] = React.useState({ x: 0, y: 0, pixelRatio: 0 })\n\n  const mouseMove = (e: { clientX: any; clientY: any }) => {\n    const { clientX, clientY } = e\n    setMouse({\n      x: clientX,\n      y: clientY,\n      pixelRatio: Math.min(window.devicePixelRatio, 2),\n    })\n  }\n\n  React.useEffect(() => {\n    window.addEventListener(\"mousemove\", mouseMove)\n    return () => {\n      window.removeEventListener(\"mousemove\", mouseMove)\n    }\n  }, [])\n\n  return mouse\n}\n\nfunction useDimension() {\n  const [dimension, setDimension] = React.useState({\n    width: 0,\n    height: 0,\n    pixelRatio: 1,\n  })\n\n  React.useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      const resize = () => {\n        setDimension({\n          width: window.innerWidth,\n          height: window.innerHeight,\n          pixelRatio: window.devicePixelRatio,\n        })\n      }\n\n      resize()\n\n      window.addEventListener(\"resize\", resize)\n\n      return () => window.removeEventListener(\"resize\", resize)\n    }\n  }, [])\n\n  return dimension\n}\n\nconst fragment = `\nuniform sampler2D uTexture;\nuniform sampler2D uDisplacement;\nuniform vec4 winResolution;\nvarying vec2 vUv;\nfloat PI = 3.141592653589793238;\n\nvoid main() {\n  vec2 vUvScreen = gl_FragCoord.xy / winResolution.xy;\n\n  vec4 displacement = texture2D(uDisplacement, vUvScreen);\n  float theta = displacement.r*2.0*PI;\n\n  vec2 dir = vec2(sin(theta),cos(theta));\n  vec2 uv = vUvScreen + dir*displacement.r*0.075;\n  vec4 color = texture2D(uTexture,uv);\n\n  gl_FragColor = color;\n}\n`\n\nconst vertex = `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`\n",
      "path": "ui/image-ripple.tsx",
      "target": "components/ui/image-ripple.tsx"
    }
  ]
}